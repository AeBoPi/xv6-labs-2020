# 实验2 A kernel pate table per process
## 实验目标
本 Lab 目标是让每一个进程进入内核态后，都能有自己的独立内核页表，为第三个实验做准备

### 创建进程内核页表与内核栈
1. 首先在进程的结构体 proc 中，添加一个kernelpgtbl，用于存储进程专享的内核态页表。

2. 修改kvminit (vm.c)
>
    内核需要依赖内核页表内一些固定的映射的存在才能正常工作，例如 UART 控制、硬盘界面、中断控制等。而 kvminit 原本只为全局内核页表 kernel_pagetable 添加这些映射。我们抽象出来一个可以为任何我们自己创建的内核页表添加这些映射的函数 kvm_map_pagetable()。

    kvminit_newpgtbl()函数用来新建内核页表

    原有的 kvminit() 函数中仍然保留新建的全局内核页表，用于 boot 过程，以及无进程运行时使用

    为 kvmmap() 函数和 kvmpa() 函数添加一个pagetable_t类型参数
>
3. 处理内核栈
>
    原本的 xv6 设计中，所有处于内核态的进程都共享同一个页表，即意味着共享同一个地址空间。由于 xv6 支持多核/多进程调度，同一时间可能会有多个进程处于内核态，所以需要对所有处于内核态的进程创建其独立的内核态内的栈，也就是内核栈，供给其内核态代码执行过程。

    xv6 在启动过程中，会在 procinit() 中为所有可能的 64 个进程位都预分配好内核栈 kstack，具体为在高地址空间里，每个进程使用一个页作为 kstack，并且两个不同 kstack 中间隔着一个无映射的 guard page 用于检测栈溢出错误。

    在 xv6 原来的设计中，内核页表本来是只有一个的，所有进程共用，所以需要为不同进程创建多个内核栈，并 map 到不同位置（见 procinit() 和 KSTACK 宏）。而我们的新设计中，每一个进程都会有自己独立的内核页表，并且每个进程也只需要访问自己的内核栈，而不需要能够访问所有 64 个进程的内核栈。所以可以将所有进程的内核栈 map 到其各自内核页表内的固定位置（不同页表内的同一逻辑地址，指向不同物理内存）。
    
>
### 切换到进程内核页表
// kernel/proc.c 在调度器将 CPU 交给进程执行之前，切换到该进程对应的内核页表

这样，每个进程执行的时候，就都会在内核态采用自己独立的内核页表了
### 释放进程内核页表
// kernel/vm.c 添加释放内核页表的函数kvm_free_kernelpgtbl()，递归释放整个多级页表数，由free walk()修改而来。

// kernel/proc.c 添加释放进程的内核栈部分

注意到我们的修改影响了其他代码： virtio 磁盘驱动 virtio_disk.c 中调用了 kvmpa() 用于将虚拟地址转换为物理地址，这一操作在我们修改后的版本中，需要传入进程的内核页表。
